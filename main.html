<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Turtle</title>
</head>
  <script src="pixi.js"></script>
  
<body>
  <script type="text/javascript">
	//check if PIXI is loaded 
    var type = "WebGL"
    if(!PIXI.utils.isWebGLSupported())
	{
      type = "canvas"
    }
    PIXI.utils.sayHello(type);
	
	//global vars
	var t;
	var commands = [];
	var screenWidth = 512;
	var screenHeight = 512;
	
	//stage container
	var pixiStage = new PIXI.Container();
	
	//pixi Graphics
	var graphics = new PIXI.Graphics();
	//setting this will make all adjustment relative to this as origin
	//graphics.position.set(x, y);
	
	//renderer
	var renderer = PIXI.autoDetectRenderer(screenWidth, screenHeight);
	document.body.appendChild(renderer.view);
	renderer.backgroundColor = 0xd4cece;
	renderer.view.style.border = "1px solid black";
	
	//load texture
	PIXI.loader
	.add("arrow.png") // turtle
	.add("fracture1.png") // background image
	.add("circle.png") // mask
	.add("checkered.png") // skin
	.load(setup); //calls setup after resources are done loading
	
	class Turtle
	{			
		//constructor
		constructor(stage)
		{	
			//this tells JS to assume that member variable called .whatever exists within calling object, and to work with it
			this.stage = stage;
			this.graphics = graphics;
			this.sprite = new PIXI.Sprite(PIXI.loader.resources["arrow.png"].texture);
			this.guts = new PIXI.Sprite(PIXI.loader.resources["fracture1.png"].texture);
			this.skin = new PIXI.Sprite(PIXI.loader.resources["checkered.png"].texture);
			this.mask = new PIXI.Sprite(PIXI.loader.resources["circle.png"].texture);
			
			this.mask.anchor.set(0.5);
			this.mask.x = 256;
			this.mask.y = 256;
			this.skin.mask = this.mask;
			
			this.sprite.scale.set(0.05, 0.05);
			this.sprite.anchor.set(0.5);
			this.sprite.x = screenWidth/2;
			this.sprite.y = screenHeight/2;
			this.sprite.rotation = 0;
			this.penIsDown = true;
			
			stage.addChild(this.guts);
			stage.addChild(this.sprite);
			stage.addChild(this.graphics);
			stage.addChild(this.mask);
			stage.addChild(this.skin);
		}
		
		moveMask()
		{
			this.mask.x = this.sprite.x;
			this.mask.y = this.sprite.y;
		}
		
		right(integer)
		{
			commands.push(['right', integer]);
		}
		left(integer)
		{
			commands.push(['left', integer]);
		}
		forward(integer)
		{
			commands.push(['forward', integer]);
		}
		back(integer)
		{
			commands.push(['back', integer]);
		}
		up()
		{
			commands.push(['up']);
		}
		down()
		{
			commands.push(['down']);
		}
		reset()
		{
			commands.push(['reset']);
		}
		
		cmd_right(t, integer)
		{
			t.targetRotation = integer * (Math.PI/180);
			t.startRotation = t.sprite.rotation;
			return;
		}
		
		cmd_left(t, integer)
		{
			t.targetRotation = -integer * (Math.PI/180);
			t.startRotation = t.sprite.rotation;
			return;
		}
		
		cmd_forward(t, integer)
		{	 
			var targetPosition = {};
			var startPosition = {};
			targetPosition.x = t.sprite.x + integer * Math.cos(t.sprite.rotation);
			targetPosition.y = t.sprite.y + integer * Math.sin(t.sprite.rotation);
			startPosition.x = t.sprite.x;
			startPosition.y = t.sprite.y;
			t.targetPosition = targetPosition;
			t.startPosition = startPosition;
			t.drawLine(t.sprite.x, t.sprite.y, t.sprite.x, t.sprite.y);			
			return;
		}	
		
		cmd_back(t, integer)
		{	
			var targetPosition = {};
			var startPosition = {};
			targetPosition.x = t.sprite.x - integer * Math.cos(t.sprite.rotation);
			targetPosition.y = t.sprite.y - integer * Math.sin(t.sprite.rotation);
			startPosition.x = t.sprite.x;
			startPosition.y = t.sprite.y;
			t.targetPosition = targetPosition;
			t.startPosition = startPosition;
			t.drawLine(t.sprite.x, t.sprite.y, t.sprite.x, t.sprite.y);			
			return;
		}	
		
		cmd_up()
		{
			t.penIsDown = false;
			return;
		}
		
		cmd_down()
		{
			this.penIsDown = true;
			return;
		}
		
		cmd_reset(t)
		{
			t.sprite.x = screenWidth/2;
			t.sprite.y = screenHeight/2;
			t.sprite.rotation = 0;
			t.moveMask();
			t.graphics.clear();
			return;
		}
		
		drawLine(beginX, beginY, endX, endY)
		{
			if(this.penIsDown == true)
			{
				this.graphics.lineStyle(3, 0xFF0000);
				this.graphics.moveTo(beginX, beginY);
				this.graphics.lineTo(endX, endY);
				//console.log(startingX, startingY, this.sprite.x, this.sprite.y);
				//console.log("drew a line");
			}
		}		
	}	
	function updateTurtleSprite()
	{
		if(t.stepTimer != null && t.stepTimeRemaining > 0)
		{
			t.stepTimeRemaining -= 32;
			if(t.stepTimeRemaining < 0)
				t.stepTimeRemaining = 0;
			setTimeout(updateTurtleSprite, 32);
		}else{
			return;
			}
			
		var x = (t.stepTimer - t.stepTimeRemaining) / t.stepTimer;
			
		if(t.targetRotation != null)
		{
			t.sprite.rotation = t.targetRotation * x + t.startRotation * (1 - x); 
		}
		
		if(t.targetPosition != null)
		{
			var oldPosition = {};
			oldPosition.x = t.sprite.x;
			oldPosition.y = t.sprite.y;
			t.sprite.x = t.targetPosition.x * x + t.startPosition.x * (1 - x);
			t.sprite.y = t.targetPosition.y * x + t.startPosition.y * (1 - x);
			//t.graphics.clear();
			t.drawLine(oldPosition.x, oldPosition.y, t.sprite.x, t.sprite.y);
			t.moveMask();
		}
	}
	
	function setup()
	{
		t = new Turtle(pixiStage);
		
		setTimeout(commandList, 500);
		setInterval(runIt, 32);
		renderer.render(pixiStage);
	}
	
	function commandList()
	{
		<!-- commands.push([t.forward, 50]); -->
		<!-- commands.push([t.right, 90]); -->
		<!-- commands.push([t.forward, 100]);	 -->
		<!-- commands.push([t.back, 150]); -->
		t.forward(50);
		t.right(90);
		t.forward(100);
		t.back(150);
		t.reset();
		//commands.push(['forward', 50]);
		//commands.push(['right', 90]);
		//commands.push(['forward', 100]);	
		//commands.push(['back', 150]);
		updateTurtleCommands();
	}
	
	function turtleStep(command)
	{
		var nextStep = 0;
		switch(command[0])
		{
		case 'forward':
			t.cmd_forward(t, command[1]);
			nextStep = command[1]/25 * 1000;
		break;
		case 'back':
			t.cmd_back(t, command[1]);
			nextStep = command[1]/25 * 1000;
		break;
		case 'left':
			t.cmd_left(t, command[1]);
			nextStep = command[1]/90 * 1000;	
		break;
		case 'right':
			t.cmd_right(t, command[1]);
			nextStep = command[1]/90 * 1000;
		break;
		case 'up':
			t.cmd_up(t);
		break;
		case 'down':
			t.cmd_down(t);
		break;
		case 'reset':
			t.cmd_reset(t);
		break;
		}
		return nextStep;
	}
	
	function updateTurtleCommands()
	{
		var hasNext = true;
		console.log("Update Turtle Commands started.");
		if(t.stepTimer > 0)
		{
			t.stepTimeRemaining = 0;
			updateTurtleSprite();
			console.log("Update Turtle Sprite Forced to Run at 0.");
		}
		t.targetPosition = null;
		t.targetRotation = null;
		t.startPosition = null;
		t.startRotation = null;
		if(commands == null || commands.length <= 0)
			return;
		
		console.log("running command " + commands[0]);
		var command = commands[0];
		if(command != null)
		{
			var timer = turtleStep(command);
			setTimeout(updateTurtleCommands, timer);
			t.stepTimeRemaining = timer;
			t.stepTimer = timer;
			if(timer > 0)
				updateTurtleSprite();
			
			console.log("Waiting " + timer + " milliseconds.");
			commands.shift();
		}
	}
	
	function runIt()
	{
		pixiStage.removeChild(t.sprite);
		pixiStage.addChild(t.sprite);
		renderer.render(pixiStage);
		
	}
	//cmd_reset();
	
  </script>
</body>

</html>