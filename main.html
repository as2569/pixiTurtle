<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Turtle</title>
</head>
  <script src="pixi.js"></script>
  
<body>
  <script type="text/javascript">
	//check if PIXI is loaded 
    var type = "WebGL"
    if(!PIXI.utils.isWebGLSupported())
	{
      type = "canvas"
    }
    PIXI.utils.sayHello(type);
	
	//turtle variable
	var t;
	var screenWidth = 512;
	var screenHeight = 512;
	
	//stage container
	var pixiStage = new PIXI.Container();
	
	//pixi Graphics
	var graphics = new PIXI.Graphics();
	//setting this will make all adjustment relative to this as origin
	//graphics.position.set(x, y);
	
	//renderer
	var renderer = PIXI.autoDetectRenderer(screenWidth, screenHeight);
	document.body.appendChild(renderer.view);
	renderer.backgroundColor = 0xd4cece;
	renderer.view.style.border = "1px solid black";
	
	//load texture
	PIXI.loader
	.add("arrow.png")
	.load(setup); //calls setup after resources are done loading
	
	class Turtle
	{			
		//constructor
		constructor(stage)
		{	
			//this tells JS to assume that member variable called .whatever exists within calling object, and to work with it
			this.stage = stage;
			this.graphics = graphics;
			this.sprite = new PIXI.Sprite(PIXI.loader.resources["arrow.png"].texture);
			this.sprite.scale.set(0.05, 0.05);
			this.sprite.x = screenWidth/2;
			this.sprite.y = screenHeight/2;
			this.sprite.rotation = 0;
			this.penIsDown = true;
			stage.addChild(this.sprite);
			stage.addChild(this.graphics);
		}
		
		right(integer)
		{
			this.sprite.rotation = integer * (Math.PI/180);
			return;
		}
		
		left(integer)
		{
			this.sprite.rotation = -1 * (integer * (Math.PI/180));
			return;
		}
		
		forward(integer)
		{	 
			var currentX = this.sprite.x;
			var currentY = this.sprite.y;
			this.sprite.x = this.sprite.x + integer * Math.cos(this.sprite.rotation);
			this.sprite.y = this.sprite.y + integer * Math.sin(this.sprite.rotation); 
			this.drawline(currentX, currentY, this.sprite.x, this.sprite.y);
			
			return;
		}	
		
		back(integer)
		{	
			this.sprite.x = this.sprite.x - integer * Math.cos(this.sprite.rotation);
			this.sprite.y = this.sprite.y - integer * Math.sin(this.sprite.rotation); 
			return;
		}	
		
		penup()
		{
			this.penIsDown = false;
			console.log(this.penIsDown);
			return;
		}
		
		pendown()
		{
			this.penIsDown = true;
			console.log(this.penIsDown);
			return;
		}
		
		drawline(beginX, beginY, endX, endY)
		{
			if(this.penIsDown == true)
			{
				this.graphics.lineStyle(3, 0xFF0000);
				this.graphics.moveTo(beginX, beginY);
				this.graphics.lineTo(endX, endY);
				//console.log(startingX, startingY, this.sprite.x, this.sprite.y);
				//console.log("drew a line");
			}
		}	
		
	}	

	//eventually this function should be separated into SETUP and RUNNING functions
	function setup(t)
	{
		t = new Turtle(pixiStage);

		t.forward(150);
		//t.drawline();
		
		//renderer to stage
		renderer.render(pixiStage);
	}
	
	function gameLoop()
	{
		requestAnimationFrame(gameLoop);		
		renderer.render(pixiStage);
	}
	
  </script>
</body>

</html>